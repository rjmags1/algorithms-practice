# 18. 4Sum - Medium

Given an array nums of `n` integers, return an array of all the unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that:

- `0 <= a, b, c, d < n`
- `a`, `b`, `c`, and `d` are distinct.
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

You may return the answer in any order.

##### Example 1:
```
Input: nums = [1,0,-1,0,-2,2], target = 0
Output: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

##### Example 2:

```
Input: nums = [2,2,2,2,2], target = 8
Output: [[2,2,2,2]]
```

##### Constraints:
- `1 <= nums.length <= 200`
- <code>-10<sup>9</sup> <= nums[i] <= 10<sup>9</sup></code>
- <code>-10<sup>9</sup> <= target <= 10<sup>9</sup></code>

## Solution

```
# Time: O(n^k) where k == len(subsequence) summing to target
# Space: O(n) ignoring output memory
class Solution:
    def fourSum(self, nums: List[int], target: int) -> List[List[int]]:
        n = len(nums)
        if n < 4:
            return []
        
        builder = []
        nums.sort()
        result = []
        def twoSum(i, j, t):
            result = []
            while i < j:
                a, b = nums[i], nums[j]
                if a + b == t:
                    result.append([a, b])
                    while i < j and nums[i] == a:
                        i += 1
                    while j > i and nums[j] == b:
                        j -= 1
                elif a + b < t:
                    i += 1
                else:
                    j -= 1
                    
            return result
        
        def rec(i, t, elemsLeft):
            avg = t // elemsLeft
            if i < n and (avg < nums[i] or nums[-1] < avg):
                return
            
            if elemsLeft == 2:
                doubles = twoSum(i, n - 1, t)
                for double in doubles:
                    result.append(builder + double)
                return
                    
            for j in range(i, n):
                if j > i and nums[j] == nums[j - 1]:
                    continue
                builder.append(nums[j])
                rec(j + 1, t - nums[j], elemsLeft - 1)
                builder.pop()
        
        rec(0, target, 4)
        return result
```

## Notes
- To consider space complexity without ignoring output, consider worst case input of `[-x, -x + 1, ..., 0, ..., x - 1, x]`, which yields <code>O(n<sup>2</sup>)</code>.
- There is an iterative solution that does not extrapolate to any k-sum problem, with roughly <code>O(n<sup>2</sup>)</code> runtime with two for-loops, but this solution is cleaner and more recognized.
- The extra base case for the recursive solution considers when it is pointless to keep searching in a subarray ending at `n - 1` with the given sub-`k` size subsequence and resulting target `t`. This happens when all the remaining numbers are either too small or too large for the current subsequence to generate any valid `k` length subsequences.